1) что делает setState()
2) что такое Virtual DOM
3) как отрисовать массив элементов
4) разница между контролируемыми и неконтролируемыми компонентами
5) жизненный цикл компонента и его методы
6) какие основные реакт хук вы знаете и используете
7) как отследить демонтирование функционального компонента
8) в каких случаях можно использовать локальное состояние, а в каких лучше использовать глобальный state
9) что такое reducer и какие параметры он принимает
10) что такое action и как изменить состояние
11) что такое JSX
12) в чем разница таких вызовов setState
13) что такое props


1) что делает setState()

У каждого компонента в react js есть состояние, которое хранит в себе
Какие-то данные: и чтобы изменить эти данные необходимо вызвать
Функцию setState 
- метод setState следит за изменением состояния Компонента, а состояние в свою очередь является объектом и когда этот объект меняется (при вызове функции setState) компонент рендериться повторно и мы видим в браузере
Компонент с обновленными данными что позволяет нам напрямую не взаимодействовать с DOM деревом

2) что такое Virtual DOM

Виртуальное дом дерево это копия оригинального ДОМ дерева и предназначено оно для того чтобы сосредоточиться на логике взаимодействия с данными напрямую и не работать с ДОМ деревом

То есть мы можем изменения вносить в копию исходя из наших потребностей, а после этого применять эти изменения к реальному ДОМ: при этом присходит сравнение ДОМ дерева с его виртуальной копией, определяется разница и запускается перерисовка только тех компонентов, которые были изменены

Такой подход быстрее, так как операции с DOM очень дороги и тяжеловесны

3) как отрисовать массив элементов

Для этого используется функция map внутри которой мы пишем jsx разметку

Const numbers = [1,2,3,4,5]

Const listItems = numbers.map(n => {
	<li>n</li>
})

При этом реакт требует указывать ключ key для каждого элемента итерации,
Ключи помогают реакту идентифицировать какие элементы были изменены, добавлены или удалены

Ключи должны быть заданы элементом внутри массива, чтобы предоставить элементам постоянный идентификатор

КЛЮЧОМ НЕ ЖЕЛАТЕЛЬНО УКАЗЫВАТЬ ИНДЕКС ЭЛЕМЕНТА В МАССИВЕ

4) разница между контролируемыми и неконтролируемыми компонентами

Контролируемый компонент - является таким поскольку value этого input является состоянием, и мы отслеживаем функцию onChange и вручную перезаписываем значение:

Такие компоненты называют управляемыми поскольку процесс изменения значения полностью нам подконтролен 

Function App() {

Const [value, setValue] = useState('')
Const changeHandler = (e) => {
	setValue(e.target.value)
}

Return (
	<div>
		<input type="text" value={value} onChange={{e => changeHandler(e)}}/>
	</div>
)

}

Теперь неконтролируемые: здесь мы уже явно никак не управляем изменениями состояния, мы создаем ссылку ref и указываем ее в компоненте input, затем мы можем напрямую обращаться к свойствам компонента, например получить value

Function App(){
	const inputRef = useRef()

	Const getInputValue = () => {
		return inputRef.current.value
	}

	return (
		<div>
			<input type="text" ref={inputRef}/>
		</div>
	)
}

5) жизненный цикл компонента и его методы

- initialisation инициализация: на этом этапе компонент реакт готовит установку начального состояния и параметров по умолчанию
- mounting монтирование: компонент реакт готов для монтирования в ДОМ дерево браузера. Этот этап охватывает методы жизненного цикла такие как 
	- component will mount
	- component did mount
- updation обновление: на этом этапе компонент обновляется двумя способами
	- отправляя новые свойства
	- обновляя состояние 
Этот этап охватывает методы жизненного
		- should component update
		- component will update
		- component did update
- unmounting размонтирование: на этом этапе компонент не нужен и удаляется из ДОМ браузера
	- включает метод жизненного цикла component will unmount

6) какие основные реакт хук вы знаете и используете

Основные:

useState()
useEffect()

Дополнительные:

useContext()
useReducer()
useMemo()
useCallback()
useRef()
И другие

-useState
Const [state, setState] = useState(initialState)
Предназначен для управления состояния функционального компонента,
Функция useState возвращает кортеж, где первый элемент это само
Состояние, а второй элемент это функция, которая это состояние обновляет

setState используется для обновления состояния: она принимает
Новое значение и ставит в очередь повторный рендер компонента

-useEffect

useEffect(
() => {
	const subscription = props.source.subscribe()
	return () => {
		subscription.unsubscribe()
	}
},
[props.source],
)

Перым параметром принимает функцию, а вторым массив зависимостей,
В который передаются переменные

Если массив зависимости пустой, то функция переданная первым параметром
Отработает лишь единожды, когда компонент был отрендерен. Если же
Мы передаем какие-либо зависимости в массив, то каждый раз при изменении
Какой-то из этих зависимостей функция будет вызываться вновь

7) как отследить демонтирование функционального компонента

useEffect(
() => {
	const subscription = props.source.subscribe()
	return () => {
		// clear subscription	
		subscription.unsubscribe()
	}
}
)

Часто эффекты создают какие-либо ресурсы, которые необходимо 
Очистить или сбросить перед тем как компонент покидает экран
(Например подписку или идентификатор таймера)

Чтобы это сделать функция переданная в useEffect может вернуть
Функцию, которая отработает именно в момент удаления компонента из
Пользовательского интерфейса: кроме того если компонент рендериться
Несколько раз - то предыдущий эффект очищается до выполнения следующего
(Это при условии если мы указали какие-то зависимости в массиве)

8) в каких случаях можно использовать локальное состояние, а в каких лучше использовать глобальный state

Локальное состояние - рекомендуется использовать в тех случаях, когда оно
Используется только в рамках одного компонента и не планируется передавать его в другие компоненты; также локальное состояние используется в компоненте какого-то отдельного элемента списка - все остальные варианты лучше выносить в глобальное состояние

9) что такое reducer и какие параметры он принимает

Чистая функция, которая принимает состояние и action

Function reducer(state, action){
	switch (action.type){
		case "INCREMENT":
			return state
		case "DECREMENT":
			return state
	}
}

Внутри reducer в зависимости от типа action мы возвращаем состояние

10) что такое action и как изменить состояние

Action это простой JS объект у которого обязательно должно быть поле с типом, также опционально можно добавить какие-то данные; для того
Чтобы изменить состояние нужно вызвать dispatch и туда положить action

Const action = {
	type: 'type',
	payload: 'payload'
}

11) что такое JSX

По умолчанию для того чтобы создавать элементы в реакте использовался
Синтаксис ниже

Const element = React.createElement(
'H1',
{className: 'greeting'},
'Hello, world'
)

Но мы привыкли видеть его вот таким

Const element = (
	<h1 className="greeting">
		Hello, world!
	</h1>
)

Именно такая разметка называется JSX: некоторое расширение языка, упрощающее написание кода и разработку

12) в чем разница таких вызовов setState

Const [state, setState] = useState(0)
setState(state + 1)

Const [state, setState] = useState(0)
setState(prevValue => prevValue + 1)

Где коллбэк - состояние будем меняться столько раз, сколько было вызовов
Где значение - состояние измениться лишь единожды, так как во все вызовы передастся текущее состояние

13) что такое props

Параметры, которые мы передаем в компонент, доступны только для чтения и не могут быть изменены