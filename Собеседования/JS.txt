1) Какие типы данных существуют в JS?
2) В чем разница между двумя операторами "==" и тремя "==="
3) Какими способами можно объявить переменную, назовите отличия
4) В чем разница между null и undefined
5) map, filter, reduce, foreach для чего нужны, особенности использования
6) Отличие стрелочных функций от функций объявленных через function
7) Что такое замыкание
8) Что такое шаблонные литералы и для чего они нужны
9) Что такое set и map
10) Как определить наличие какого-либо свойства или же поля в объекте?
11) Какие способы создания объекта вы знаете
12) Какие значения будут являться falsy значениями или же ложными
13) Что такое Promise
14) Как использовать async await для асинхронных запросов
15) Для чего нужен оператор spread 
16) Как избежать ссылочной зависимости при копировании объекта
17) Как поменять контекст функции
18) Что такое тернарный оператор
19) Что такое деструктуризация
20) Какие способы работы с асинхронным кодом вы знаете
21) e.preventDefault() и stopPropagination() для чего они нужны
22) Как отслеживать и обрабатывать ошибки в JS
23) Что такое DOM дерево
24) Что такое прототипное наследование
25) Как получить свойство объекта


1) Какие типы данных существуют в JS?

8 типов данных:

Number = 5
String = 'строка'
Boolean = true\false
null (ничего, пусто или значение "неизвестно" - обычно оно задается явно)
undefined (переменная объявлена, но не присвоено никакого значения)
Object = {name: "Yuri"}, Array, Function
Symbol = new Symbol("id") (уникальный идентификатор в объектах)
Bigint = 1234567890123456789n (для создания очень больших чисел)

2) В чем разница между двумя операторами "==" и тремя "==="

Двойное равенство сравнивает с приведением типов
Тройное равенство является строгим (как по типу так и по значению)

0 == false // true
1 == true // true
1 == "1" // true

0 === false // false
1 === true // false
1 === "1" // false

3) Какими способами можно объявить переменную, назовите отличия

A = 5
Var b = 10

Глобальная или функциональная область видимости (var или просто название)
Не имеют блочной области видимости

Let c = "let"
Const obj = {}

Имеют блочную область видимости, то есть объявленная в блоке if переменная, будет 
Доступна только в этом блоке

Const - если массив или объект, то в объекте можно изменять или добавлять поля, а в массиве опять же или добавлять, удалять, видоизменять каждый из элементов

4) В чем разница между null и undefined

Оба варианта означают пустое значение, но если мы инициализируем переменную, но 
Не присваиваем ей значение - туда помешается специальный маркер, 
который отображается как undefined

Null - мы помешаем самостоятельно, он обозначает пустое значение, ничего, пусто

Если же мы хотим очистить значение переменной, то мы как раз приравниваем ее к null

5) map, filter, reduce, foreach для чего нужны, особенности использования

Каждый из этих методов итерируется по массиву

forEach - ничего не возвращает, его используют только для перебора элементов, это
Более элегантный вариант чем обычный цикл for 

Filter - принимает первым параметром callback, и используется через функцию, он всегда
Возвращает новый массив, в который войдут те элементы, для которых callback возвратит
True

Map - используется для трансформации массива, он создает новый массив, который будет
Состоять из результатов вызова функции callback, которую мы передаем параметром
Для каждого элемента массива

Reduce - используется для последовательной обработке каждого элемента массива с
Сохранением какого-то промежуточного результата - этот результат и будет
Возвращаться по выполнению функции

Let arr = [1,2,3,4,5]

// для каждого элемента массива запустить функцию,
// промежуточный результат передавать первым аргументом далее

Let result = arr.reduce(function(sum, current) {
	return sum + current;
}

console.log(result) // 15

6) Отличие стрелочных функций от функций объявленных через function

В стрелочных функциях нельзя использовать ключевое слово arguments
Отличие в синтаксисе
У стрелочных функций нет своего this. Если идет обращение к this то оно берется снаружи
Не могут быть вызваны с new

7) Что такое замыкание

Замыкание - это функция вместе со всеми внешними переменными, которые ей доступны

Например: есть функция, которая имеет вложенную функцию, и вложенная функция будет
Сохранять и замыкать внутри себя переменные, которые объявлены в родительской

Function parent(number){
	return function child(){
		console.log(number) // child замыкает в себе number
	}
}

8) Что такое шаблонные литералы и для чего они нужны

Косые кавычки - можно прямо напрямую в строку вставлять какие-то переменные (${user}),
В них разрешен перенос строки, что позволяет встраивать html в js без лишних
Махинаций (без \n)

9) Что такое set и map

Map - это структура данных ключ, значение, как обычный объект JS. Но основное отличие
В том, что map позволяет использовать ключи любого типа.

Set - это также структура данных, своего рода массив, где каждое значение может 
Появиться только один раз, то есть абсолютно все значения находящиеся в коллекции
Являются уникальными.

10) Как определить наличие какого-либо свойства или же поля в объекте?

Const obj = {
	a: 5,
	b: "string"
}

console.log(obj.hasOwnProperty("a")) // true
console.log("b", in obj) // true

11) Какие способы создания объекта вы знаете

- с помощью функций

Function User(name, surname){
	this.name = name
	this.surname = surname
}

Const user = new User('Yury', 'Kishko')
console.log(user) // User {name: 'Yury', surname: 'Kishko'}

- c помощью литеральной нотации

MyObject = {
	id: "1",
	name: "Sample"
}

- c помощью класса

Class User(name, surname){
	constructor(name, surname){
		this.name = name
		this.surname = surname
	}
}

Const user = new User('Yury', 'Kishko')
console.log(user) // User {name: 'Yury', surname: 'Kishko'}

12) Какие значения будут являться falsy значениями или же ложными

console.log(false)
console.log(!!0)
console.log(!!"")
console.log(!!undefined)
console.log(!!null)
console.log(!!NaN)
console.log(!!BigInt(0))

13) Что такое Promise

Promise - это специальный объект, предназначенный для работы с асинхронным кодом и
Который содержит свое состояние. Вначале pending (ожидание), затем одно из: 
- fulfilled (выполнено успешно)
- rejected (выполнено с ошибкой)

New Promise(resolve, reject) => {
	setTimeout( () => {
		resolve('DONE')
	}, 1000)
})
	.then(data => console.log(data)) // log DONE
	.catch(error => console.log(error)) // error

Громимы пришли на замену функциям обратного вызова, так называемым callback 

14) Как использовать async await для асинхронных запросов

Начнем с того, что из себя представляет async await

Async await это своего рода способ для работы с промисами

Функция помеченная как async всегда будет оборачивать результат который возвращает функция в Promise

Своего рода просто синтаксический сахар для работы с промисами

Если кратко то функция помечается как async, а внутри нее мы можем использовать ключевое слово await
Которое необходимо использовать перед асинхронными операциями, соответственно код станет синхронным
И будет выполняться в последовательном режиме

Async function fetchFromApi(url) {
	const response = await fetch(url) // код
	const json = await response.json() // будет выполняться
	json.forEach(item => console.log(item)) // последовательно
}

15) Для чего нужен оператор spread 

Оператор три точки имеет множество предназначений, но конкретно spread

Предназначен для того чтобы разворачивать массивы и объекты

Let mid = [3,4]
Let arr = [1,2, mid, 5,6]
console.log(arr) // [1,2, [3.4], 5,6]

Let mid2 = [3,4[
Let arr2 = p1,2, ... mid2, 5,6]
console.log(arr2) // [1,2,3,4,5,6]

Let firstObject = {a: 1, b: 2}
Let secondObject = {...firstObject, c: 3, d: 4}
console.log(secondObject) // {a: 1, b: 2, c: 3, d: 4}

16) Как избежать ссылочной зависимости при копировании объекта

В JS существует функция, которая предназначена для копирования объекта

Она называется assign, поскольку все объекты являются ссылками, то функция
Действительно создаст новый объект с теми же полями, но, если внутри исходного
Объекта находятся еще какие-то объекты, то ссылки на них будут сохранены

Const obj = {
	a: {
		b: 5
	}
}

Const copy = Object.assign({}, obj)
console.log(copy.a === obj.a) // true

Поэтому можно использовать вот такой костыльный способ

Const obj = {
	a: {
		b: 5
	}
}

Const copy = JSON.parse(JSON.stringify(obj))
console.log(copy.a === obj.a) // false

17) Как поменять контекст функции

Во-первых это можно сделать с помощью функции bind, в которую параметром передает как раз контекст

Bind возвращает новую функцию, привязанную к контексту, который мы передали параметром

Function fn(){
	return this
}

Const obj = {name: 'Yury Kishko'}
Const newFn = fn.bind(obj)
console.log(newFn()) // return {name: 'Yury Kishko'}

Также существует еще два способа, с помощью функции call и apply

Function fn(arg1, arg2){
	console.log(arg1, arg2)
	Return this
}

Const obj = {name: 'Yury Kishko'}

fn.call(obj, "arg1", "arg2") 
// log = arg1, arg2
// return {name: 'Yury Kishko'} // принимает параметры в виде перечисления через запятую

Fn.apply(obj, ["arg1", "arg2"]) 
// log = arg1, arg2
// return {name: 'Yury Kishko'} // принимает параметры через массив

18) Что такое тернарный оператор

Это аналогичный if else оператор - который представлен знаком вопроса

If (условие){
	тогда
} else {
	иначе;
}

Let result = условие ? Тогда : иначе;

19) Что такое деструктуризация

В JS есть две чаще всего используемые структуры данных:
- объект
- массив

Деструктурирующее присваивание это специальный синтаксис, который позволяет нам распаковать
Массивы или объекты в кучу переменных, так как иногда они более удобны

Let arr = ["ULBI", "TV"]

// записывает firstName = ULBI surname = TV
Let [firstName, surName] = arr

Let options = {
	title: "Menu",
	width: 100,
	height: 200
}

Let {title, width, height} = options

20) Какие способы работы с асинхронным кодом вы знаете

- первый и самый старый способ это функция обратного вызова callback

Function loadScript(src, callback) {
	let script = document.createElement('script')
	script.src = src

	script.onload = () => callback(script)

	document.head.append(script)
}

- второй способ это Promise

New Promise((resolve, reject) => {
	setTimeout(() => {
		resolve("data")
	}, 500)
}).then(data => console.log(data))
.catch(error => console.log(error))

- третий способ - с помощью специального синтаксиса по работе с проминами async await

Async function fetchData(url){
	const rest = await fetch(url)
	const json = await resp.json()
	console.log(json) // асинхронный код будет выполняться последовательно
}

21) e.preventDefault() и stopPropagination() для чего они нужны

Function submitForm(event){
	event.preventDefault()
}

Как вы знаете в JS есть огромное количество событий: это нажатие на кнопку, движение мыши
Отпускание кнопки мыши, нажатие на кнопки клавиатуры и так далее

И многие из этих событий автоматически ведут за собой какое-то действие браузера

Например клик по ссылке инициирует переход на новую страницу или нажатие на кнопку
Отправить в форме отправляет что-то какие-то данные на сервер

И чтобы эти действия по умолчанию отменить - используется функция preventDefault

<div onclick="alert(`сюда всплытие не дойдет`)">
	<button onclick="event.stopPropagation">Кликни меня</button>
</div>

Допустим у вас есть блок див внутри которого кнопка и вы вешаете слушатель события на этот div,
Но этот же слушатель события будет обрабатываться и для кнопки - такое поведение называется всплытие

Если вы хотите это всплытие предотвратить, вызовите функцию stopPropagination у кнопки

И она перестанет слушать события в блоке div

22) Как отслеживать и обрабатывать ошибки в JS

С помощью специальной конструкции try catch - которая позволяет отлавливать
Ошибки и вместо падения приложения делать нечто более осмысленное

Try {
	// код
} catch (err) { // переменная err содержит объект ошибки с подробной информацией о произошедшем
	// код в этом блоке выполнится если в блоке try произошла ошибка
} finally {
	// код в этом блоке выполнится
	// в любом случае
}

23) Что такое DOM дерево

DOCUMENT OBJECT MODEL

Каждый html тег является объектом, вложенные теги являются детьми родительского объекта,
Текст который находится внутри тега также является объектом - все эти объекты 
Доступны внутри JS - и мы можем использовать их для изменения страницы

24) Что такое прототипное наследование

Изначально в JS каждый объект обладает свойством "прототипом"
- вы можете добавлять в него методы и свойства
- создавать другие объекты на основе этого прототипа (и создаваемый объект автоматически унаследует свойства своего прототипа)

- если свойства в новом объекте отсутствуют, то будет произведен поиск в его прототипе

25) Как получить свойство объекта

Const obj = {
	name: 'Yury'
}

Obj.name
obj['name']