1) Какие типы данных существуют в JS?
2) В чем разница между двумя операторами "==" и тремя "==="
3) Какими способами можно объявить переменную, назовите отличия
4) В чем разница между null и undefined
5) map, filter, reduce, foreach для чего нужны, особенности использования
6) Отличие стрелочных функций от функций объявленных через function
7) Что такое замыкание
8) Что такое шаблонные литералы и для чего они нужны
9) Что такое set и map
10) Как определить наличие какого-либо свойства или же поля в объекте?
11) Какие способы создания объекта вы знаете
12) Какие значения будут являться falsy значениями или же ложными
13) Что такое Promise
14) Как использовать async await для асинхронных запросов
15) Для чего нужен оператор spread 
16) Как избежать ссылочной зависимости при копировании объекта
17) Как поменять контекст функции


1) Какие типы данных существуют в JS?

8 типов данных:

Number = 5
String = 'строка'
Boolean = true\false
null (ничего, пусто или значение "неизвестно" - обычно оно задается явно)
undefined (переменная объявлена, но не присвоено никакого значения)
Object = {name: "Yuri"}, Array, Function
Symbol = new Symbol("id") (уникальный идентификатор в объектах)
Bigint = 1234567890123456789n (для создания очень больших чисел)

2) В чем разница между двумя операторами "==" и тремя "==="

Двойное равенство сравнивает с приведением типов
Тройное равенство является строгим (как по типу так и по значению)

0 == false // true
1 == true // true
1 == "1" // true

0 === false // false
1 === true // false
1 === "1" // false

3) Какими способами можно объявить переменную, назовите отличия

A = 5
Var b = 10

Глобальная или функциональная область видимости (var или просто название)
Не имеют блочной области видимости

Let c = "let"
Const obj = {}

Имеют блочную область видимости, то есть объявленная в блоке if переменная, будет 
Доступна только в этом блоке

Const - если массив или объект, то в объекте можно изменять или добавлять поля, а в массиве опять же или добавлять, удалять, видоизменять каждый из элементов

4) В чем разница между null и undefined

Оба варианта означают пустое значение, но если мы инициализируем переменную, но 
Не присваиваем ей значение - туда помешается специальный маркер, 
который отображается как undefined

Null - мы помешаем самостоятельно, он обозначает пустое значение, ничего, пусто

Если же мы хотим очистить значение переменной, то мы как раз приравниваем ее к null

5) map, filter, reduce, foreach для чего нужны, особенности использования

Каждый из этих методов итерируется по массиву

forEach - ничего не возвращает, его используют только для перебора элементов, это
Более элегантный вариант чем обычный цикл for 

Filter - принимает первым параметром callback, и используется через функцию, он всегда
Возвращает новый массив, в который войдут те элементы, для которых callback возвратит
True

Map - используется для трансформации массива, он создает новый массив, который будет
Состоять из результатов вызова функции callback, которую мы передаем параметром
Для каждого элемента массива

Reduce - используется для последовательной обработке каждого элемента массива с
Сохранением какого-то промежуточного результата - этот результат и будет
Возвращаться по выполнению функции

Let arr = [1,2,3,4,5]

// для каждого элемента массива запустить функцию,
// промежуточный результат передавать первым аргументом далее

Let result = arr.reduce(function(sum, current) {
	return sum + current;
}

console.log(result) // 15

6) Отличие стрелочных функций от функций объявленных через function

В стрелочных функциях нельзя использовать ключевое слово arguments
Отличие в синтаксисе
У стрелочных функций нет своего this. Если идет обращение к this то оно берется снаружи
Не могут быть вызваны с new

7) Что такое замыкание

Замыкание - это функция вместе со всеми внешними переменными, которые ей доступны

Например: есть функция, которая имеет вложенную функцию, и вложенная функция будет
Сохранять и замыкать внутри себя переменные, которые объявлены в родительской

Function parent(number){
	return function child(){
		console.log(number) // child замыкает в себе number
	}
}

8) Что такое шаблонные литералы и для чего они нужны

Косые кавычки - можно прямо напрямую в строку вставлять какие-то переменные (${user}),
В них разрешен перенос строки, что позволяет встраивать html в js без лишних
Махинаций (без \n)

9) Что такое set и map

Map - это структура данных ключ, значение, как обычный объект JS. Но основное отличие
В том, что map позволяет использовать ключи любого типа.

Set - это также структура данных, своего рода массив, где каждое значение может 
Появиться только один раз, то есть абсолютно все значения находящиеся в коллекции
Являются уникальными.

10) Как определить наличие какого-либо свойства или же поля в объекте?

Const obj = {
	a: 5,
	b: "string"
}

console.log(obj.hasOwnProperty("a")) // true
console.log("b", in obj) // true

11) Какие способы создания объекта вы знаете

- с помощью функций

Function User(name, surname){
	this.name = name
	this.surname = surname
}

Const user = new User('Yury', 'Kishko')
console.log(user) // User {name: 'Yury', surname: 'Kishko'}

- c помощью литеральной нотации

MyObject = {
	id: "1",
	name: "Sample"
}

- c помощью класса

Class User(name, surname){
	constructor(name, surname){
		this.name = name
		this.surname = surname
	}
}

Const user = new User('Yury', 'Kishko')
console.log(user) // User {name: 'Yury', surname: 'Kishko'}

12) Какие значения будут являться falsy значениями или же ложными

console.log(false)
console.log(!!0)
console.log(!!"")
console.log(!!undefined)
console.log(!!null)
console.log(!!NaN)
console.log(!!BigInt(0))

13) Что такое Promise

Promise - это специальный объект, предназначенный для работы с асинхронным кодом и
Который содержит свое состояние. Вначале pending (ожидание), затем одно из: 
- fulfilled (выполнено успешно)
- rejected (выполнено с ошибкой)

New Promise(resolve, reject) => {
	setTimeout( () => {
		resolve('DONE')
	}, 1000)
})
	.then(data => console.log(data)) // log DONE
	.catch(error => console.log(error)) // error

Громимы пришли на замену функциям обратного вызова, так называемым callback 

14) Как использовать async await для асинхронных запросов

Начнем с того, что из себя представляет async await

Async await это своего рода способ для работы с промисами

Функция помеченная как async всегда будет оборачивать результат который возвращает функция в Promise

Своего рода просто синтаксический сахар для работы с промисами

Если кратко то функция помечается как async, а внутри нее мы можем использовать ключевое слово await
Которое необходимо использовать перед асинхронными операциями, соответственно код станет синхронным
И будет выполняться в последовательном режиме

Async function fetchFromApi(url) {
	const response = await fetch(url) // код
	const json = await response.json() // будет выполняться
	json.forEach(item => console.log(item)) // последовательно
}

15) Для чего нужен оператор spread 

Оператор три точки имеет множество предназначений, но конкретно spread

Предназначен для того чтобы разворачивать массивы и объекты

Let mid = [3,4]
Let arr = [1,2, mid, 5,6]
console.log(arr) // [1,2, [3.4], 5,6]

Let mid2 = [3,4[
Let arr2 = p1,2, ... mid2, 5,6]
console.log(arr2) // [1,2,3,4,5,6]

Let firstObject = {a: 1, b: 2}
Let secondObject = {...firstObject, c: 3, d: 4}
console.log(secondObject) // {a: 1, b: 2, c: 3, d: 4}

16) Как избежать ссылочной зависимости при копировании объекта

В JS существует функция, которая предназначена для копирования объекта

Она называется assign, поскольку все объекты являются ссылками, то функция
Действительно создаст новый объект с теми же полями, но, если внутри исходного
Объекта находятся еще какие-то объекты, то ссылки на них будут сохранены

Const obj = {
	a: {
		b: 5
	}
}

Const copy = Object.assign({}, obj)
console.log(copy.a === obj.a) // true

Поэтому можно использовать вот такой костыльный способ

Const obj = {
	a: {
		b: 5
	}
}

Const copy = JSON.parse(JSON.stringify(obj))
console.log(copy.a === obj.a) // false

17) Как поменять контекст функции

Во-первых это можно сделать с помощью функции bind, в которую параметром передает как раз контекст

Bind возвращает новую функцию, привязанную к контексту, который мы передали параметром

Function fn(){
	return this
}

Const obj = {name: 'Yury Kishko'}
Const newFn = fn.bind(obj)
console.log(newFn()) // return {name: 'Yury Kishko'}

Также существует еще два способа