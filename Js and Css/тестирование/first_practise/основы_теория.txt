https://www.youtube.com/watch?v=y2emL1fMRyY

Цель тестирования - проверка соответствия ПО предъявляемым требованиям



Тестирование делится на два вида:

Функциональное -> все что тестирует функциональность

Модульное (unit)
Интеграционные
End-to-end(e2e)

Нефункциональное тестирование 

Нагрузочное тестирование
Тестирование безопасности
Регрессионное тестирование

Unit тестов должно быть максимально много, а e2e тестов максимально мало

Пирамида (слева-направо, как снизу-вверх)
Unit -> скриншотные тесты -> integration -> e2e

**********************************************************************
**********************************************************************

Unit тесты пишутся на отдельные маленькие кусочки системы, helpers, методы какого-то класса,
Или даже компонент, который поставляет нам какой-то UI

Скриншотные тесты - больше предназначены для UI: допустим один разработчик сверстал страничку,
Через полгода пришел другой и поменял в одном месте шрифты, при это не заметил, как они
Поменялись и в другом месте - система тестирования сравнивает старый "скрин" и "новый",
Накладывает их друг на друга и сравнивает - если разница большая то выдает результат.

Интеграционные тесты - когда мы что-либо тестируем в связке: например несколько реакт компонентов
В связке, реакт компонент в связке с редакс. Тестируем несколько модулей, но уже не по отдельности
Как при Unit тестировании, а в связке.

E2E тесты это когда на реальных данных, на реальном бэкенде, на реальном браузере - пишем такой тест,
Который сам нажимает на кнопочки, сам отправляет какие-то данные - с помощью этих тестов мы проверяем
Какую-то ключевую функциональность: авторизацию, регистрацию, удаление пользователя, оплату, важный функционал

E2E - тяжелые тесты, сложны в поддержке, долго пишутся - 10% от всех тестов максимум (в теории)
Integration - поддерживаются легче, но по времени тоже много занимают - 20-30% максимум
Все остальное - unit + скриншотные тесты 70-80%

КАК ПРАВИЛЬНО ПОДБИРАТЬ ДАННЫЕ ДЛЯ ТЕСТИРОВАНИЯ?

Один тест case надо написать на положительный результат
Второй тест case - пишем на corner кейсы - на пограничные значения - мы должны убедиться что на
Границах функция также возвращает валидный результат

Проверяем также невалидные данные

**********************************************************************
**********************************************************************

Пример

Const validateValue = (value) => {
	if (value < 0 || value > 100){
		return false
	}
	return true
}

50 положительный тест case (середина квадрата)
0, 100 пограничные значения corner case
-50, 150 невалидные значения