https://www.youtube.com/watch?v=GNrdg3PzpJQ
Основное видео

Как создать проект
https://reactjs.org/docs/create-a-new-react-app.html

Теория:

React - это библиотека для создания пользовательских интерфейсов.
Не зависит от браузера.

React DOM - за отрисовку, рендеринг, визуализацию отвечает эта библиотека.

React под капотом делает легковесную копию DOM дерева, 

(Фаза - согласование - Reconciliation - React Core)
После чего, при изменении DOM происходят изменения в React дереве элементов,

(Фаза - рендеринг - React DOM, React Native)
Далее это легковесная копия сравнивается с DOM, после чего уже идет отрисовка

Мы сосредотачиваемся на логике по работе с данными,
А за визуализацию отвечает react

####################################################

npx create-react-app my-app
cd my-app
npm start

import React from 'react'; 
- делаем это везде где используем React

import ReactDOM from 'react-dom/client'; 
- чтобы вмонтировать наш компонент в приложение

####################################################

Как мы пишем HTML разметку внутри JS файла?

Такой синтаксис называется JSX - является расширением JS и упрощает написание кода.

####################################################

useState()

Когда мы изменяем значения какой-то переменной, react не понимает, что в конкретном компоненте произошли какие-то изменения, для этого необходимо явно сообщить что вот здесь мы изменяем такое-то такое-то значение
- для этого придумано состояние, то есть каждый компонент обладает каким-то состоянием и при изменении этого состояния React понимает что произошли изменения и перерисовывает компонент

import React, {useState} from "react";

const [likes, setLikes] = useState(0)

Параметром эта функция принимает значение по умолчанию

Возвращает массив состоящий из двух элементов, при этом первый элемент это объявленное значение, а второй элемент эта функция, предназначенная для того чтобы изменять состояние

import React, {useState} from "react";

function App() {
    const [likes, setLikes] = useState(0)

    function increment() {
        setLikes(likes + 1)
    }

    function decrement() {
        setLikes(likes - 1)
    }

    return (
    <div className="App">
        <h1>{likes}</h1>
        <button onClick={increment}>Increment</button>
        <button onClick={decrement}>Decrement</button>
    </div>
    );
}

export default App;

Здесь вызвали increment, потом через него вызвали setLikes, но до этого положили setLikes в useState, чтобы эта функция могла изменять состояние likes

####################################################

useState() - two-way binding

import React, {useState} from "react";

function App() {
    const [likes, setLikes] = useState(0)
    const [value, setValue] = useState('Текст в инпуте')

    function increment() {
        setLikes(likes + 1)
    }

    function decrement() {
        setLikes(likes - 1)
    }

    return (
    <div className="App">
        <h1>{likes}</h1>
        <h1>{value}</h1>
        <input
            type="text"
            value={value}
            onChange={event => setValue(event.target.value)}
        />
        <button onClick={increment}>Increment</button>
        <button onClick={decrement}>Decrement</button>
    </div>
    );
}

export default App;

####################################################

Компонент называется так же как и файл внутри которого он расположен и всегда с большой буквы

####################################################

Хуки

useState()
useEffect()
useRef()
useMemo()
useCallback()
useContext()

Можно использовать либо в функциональных компонентах, либо в своих собственных хуках

!!! Хуки можно использовать только на верхнем уровне вложенности, то есть мы не можем вкладывать
Хуки в какие-либо функции, условия и так далее

####################################################

props - это обычный аргумент функции, в который можно что-нибудь передать
(Можно интерпретировать это так)

####################################################

Не использовать индексы массива в качестве ключей при итерации списка!

####################################################

const bodyInputRef = useRef()

С помощью этого хука мы можем получить доступ к DOM элементу и уже у этого элемента забрать value

В целом манипулировать DOM деревом в React напрямую не рекомендуется

####################################################

Мы никогда не изменяем состояние напрямую!

    const [posts, setPosts] = useState([
        {id: 1, title: 'JavaScript', body: 'Description'},
        {id: 2, title: 'JavaScript 2', body: 'Description 2'},
        {id: 3, title: 'JavaScript 3', body: 'Description 3'},
    ])
    const [title, setTitle] = useState('')
    const [body, setBody] = useState('')

    const addNewPost = (e) => {
        e.preventDefault()
        const newPost = {
            id: Date.now(),
            title,
            body
        }
        setPosts([...posts, newPost]) // !!! !!! !!! 
	// а не posts.push(newPopst)
    }

####################################################

useMemo(callback, deps)

Первым параметром callback, вторым - массив зависимостей

Callback должен возвращать результат каких-либо вычислений,

Отсортированный или отфильтрованный массив, математические операции,
Результат каких-либо вычислений (аналог computed свойств)

В массив зависимостей можно передавать какие-то переменные, поля объекта

useMemo(() => {
Return [...posts].sort(...)
}, [selectedSort, posts])

Функция useMemo производит вычисления (в примере выше сортирует массив)
Запоминает результаты этих вычислений и кэширует

На каждую перерисовку компонента - она достает отсортированный массив из кэша

####################################################

Хуки всегда должны начинаться с use (в том числе и кастомные) - это некоторое соглашение

####################################################

Жизненный цикл компонента

1-Монтирование (mount) - когда создается компонент и монтируется в DOM дерево
- Интересно в том случае, когда мы хотим сделать первичную подгрузку данных, повесить
Какие-то слушатели события, 

2-Обновление (update) -  обновление компонента, мы изменили состояние, произошел перерендер, перерисовка
Компонента - стадия активной жизни компонента, когда он работает, когда мы его видим, когда он живет
- следить за изменением каких-либо зависимостей и производить нужные нам действия

3-Размонтирование (unmount) - когда компонент не нужен и по какой-то причине мы его удаляем,
Например мы хотим его скрыть, или же мы переходим на другую страницу и за ненадобность Реакт его
Уничтожает 
- на этой стадии делаем различную очистку: отписываемся от слушателей события, очищаем глобальное хранилище, в общем все что нам необходимо удалить после того как компонент уничтожится

КАК ЗА ЭТИМИ СТАДИЯМИ СЛЕДИТЬ?

Хук useEffect(callback, deps) - который мы можем использовать столько раз сколько нам необходимо



Когда массив зависимостей deps пустой - хук useEffect(() => {fetchPosts()}, []) - отработает один раз в момент монтированная компонента



useEffect(()=> {
console.log('на изменение property будет отрабатывать как watch во Vue!')
}, [property])

При этом зависимостей мы можем передать столько, сколько потребуется

useEffect(()=> {
console.log('на изменение свойства будет отрабатывать как watch во Vue!')
}, [property, againProperty, nextProperty])

####################################################

Изменение состояния это асинхронный процесс - для чего это нужно?

Например у нас вызываются несколько функций, которые изменяют состояния - это
Вызывает к изменению каких-то дочерних компонентов, в этих компонентах происходят
Какие-то side эффекты, и в целях оптимизации React не принимает условия по одному,
А накапливает этих изменений пачку чтобы применить их разом, чтобы избегать повторных
Манипуляций с DOM

####################################################

React native DOM

npm install react-router-dom

Чтобы заработал router приложение нужно обернуть в компонент BrowserRouter, именно он будет
Отслеживать изменения пути и перерисовывать компоненты

Для того чтобы объявить какой-либо маршрут, какую-либо страницу в нашем приложении - есть
Компонент Route



Пример рабочего Router - на версию 6-8-1

import React from "react";
import './styles/App.css'
import {BrowserRouter} from "react-router-dom";
import Navbar from "./components/UI/Navbar/Navbar";
import AppRouter from "./components/AppRouter";

function App() {
    return (
        <div className="wrapper">
            <BrowserRouter>
                <Navbar/>
                <AppRouter/>
            </BrowserRouter>
        </div>
    )
}

export default App;

App-router внизу

import React from 'react';
import {Navigate, Route, Routes} from "react-router-dom";
import About from "../pages/About";
import Posts from "../pages/Posts";
import Error from "../pages/Error";

const AppRouter = () => {
    return (
        <Routes>
            <Route path='/about' element={<About/>}/>
            <Route path='/posts' element={<Posts/>}/>
            <Route path="/error" element={<Error />} />
            <Route path="/*" element={<Navigate to="/error" replace />} />
        </Routes>
    );
};

export default AppRouter;

####################################################

useContext() хук


