ЗАЧЕМ ЕГО ИСПОЛЬЗОВАТЬ?

Когда компонент разрастается не всегда удается уловить логическую связь, поддержка
и читаемость кода ухудшается, компонент разрастается до 1000 строк и что-то в нем
найти становится крайне сложно, особенно если ты раньше с этим компонентом не
работал

хотелось бы иметь возможность иметь такой фунционал, при котором мы можем сделать декомпозицию,
а также все логические куски держать рядом

преимущест у composition API достаточно много!

данные и логика по работе с этими данными - находятся рядом (когда приложение очень
большое, это очень облегчает его поддержку и работу над ним)

###########################################

БАЗОВЫЙ ПРИМЕР:

Есть некоторая функция setup, которая параметром принимает props

в компоненте 

export default {
    setup(props){

    }
}

для того чтобы сделать переменную реактивной, нужно из vue импортировать функцию ref

import {ref} from 'vue'

функция ref принимает значение, внизу проинициализировали переменную likes = 0

    setup(props){
        const likes = ref(0)

        return {
            likes
        }
    }

все то что мы вернем из функции setup будет доступно в шаблоне

можно динамески изменять количество лайков

Базовый пример

<button @click="addLike">add like</button>

    setup(props){
        const likes = ref(0)
        console.log(likes)
        const addLike = () => {
            likes.value += 1
        }

        return {
            likes,
            addLike
        }
    }

В JS примитивы сравниваются по значению - а объекты по ссылкам

###########################################




https://www.youtube.com/watch?v=V-kxBWcPJfo&list=PL4cUxeGkcC9hYYGbV60Vq3IXYNfDk8At1&index=10 - часть 1
https://www.youtube.com/watch?v=0FwBjPeLqQ8&list=PL4cUxeGkcC9hYYGbV60Vq3IXYNfDk8At1&index=11 - часть 2

export default {
  name: 'HomeView',
  setup(){
    console.log('setup')
  },
  created(){
    console.log('created')
  },
  mounted(){
    console.log('mouted')
  }
}
</script>

setup отработает самым первым, перед created и mounted

####################################################################################

  setup(){
    let name = 'mario'
    let age = 30

    const handleClick = () => {
      console.log('you clicked me')
    }

    // return {name: name, age: age, handleClick: handleClick}
    return {name, age, handleClick} // тоже самое что и наверху
  }

чтобы обратиться к данным из setup в компоненте, надо сделать их return,
однако такие данные (пока) не будут реактивными

!!! this keyword is not available inside setup()
когда мы используем это внутри lifecycle hooks или 
еще где-либо то this обращается к компоненту, а в setup это будет undefined

####################################################################################

<template>
  <div class="home">
    Home
    <p ref="p">My name is {{ name }} and my age is {{ age }}</p>
    <button @click="handleClick">Click me</button>
  </div>
</template>

<script>
// @ is an alias to /src
import { ref } from 'vue'

export default {
  name: 'HomeView',
  setup(){
    let name = 'mario'
    let age = 30

    const p = ref(null)

    const handleClick = () => {
      // console.log('you clicked me')
      console.log(p, p.value)

      p.value.classList.add('test')
      p.value.textContent = 'hello, users'
    }

    // return {name: name, age: age}
    return {name, age, handleClick, p} // тоже самое что и наверху
  }
}
</script>

ты не можешь использовать value of p перед тем как ты его return!
поэтому handleclick и работает - до этого он бы не сработал!

####################################################################################

using refs for reactivity

<template>
  <div class="home">
    Home
    <p>My name is {{ name }} and my age is {{ age }}</p>
    <button @click="handleClick">Click me</button>
  </div>
</template>

<script>
// @ is an alias to /src
import { ref } from 'vue'

export default {
  name: 'HomeView',
  setup(){
    const name = ref('mario')
    const age = ref(30)

    const handleClick = () => {
      name.value = 'luidji'
      age.value = 35
    }

    // return {name: name, age: age}
    return {name, age, handleClick} // тоже самое что и наверху
  }
}
</script>

внутри шаблона не нужно писать .value - мы делаем это только внутри setup()

####################################################################################

refs vs reactive

<template>
  <div class="home">
    <h1>Home</h1>
    <h2>Refs</h2>
    <p>{{ ninjaOne.name }} - {{  ninjaOne.age }}</p>
    <button @click="updateNinjaOne">Update ninja one</button>
    <h2>Reactive</h2>
    <p>{{ ninjaTwo.name }} - {{ ninjaTwo.age }}</p>
    <button @click="updateNinjaTwo">Update ninja two</button>
  </div>
</template>

<script>
// @ is an alias to /src
import { ref, reactive } from 'vue'

export default {
  name: 'HomeView',
  setup(){
    const ninjaOne = ref({name: 'mario', age: 30})
    const ninjaTwo = reactive({ name: 'luigi', age: 35})

    const name = ref('lora')
    const nameTwo = reactive('lera') // не сработает, так как это primitive type - минус reactive

    const updateNinjaOne = () => {
      ninjaOne.value.age = 40 // используя ref - нам нужно прописывать value property чтобы получить
      // доступ к value этого ref
    }

    const updateNinjaTwo = () => {
      ninjaTwo.age = 45 // когда мы используем reactive нам нет необходимости
      // прописывать .value
    }

    return { ninjaOne, updateNinjaOne, ninjaTwo, updateNinjaTwo}
  }
}
</script>

####################################################################################

computed properties

<template>
  <div class="home">
    <h1>Home</h1>

    <p>{{ name }}</p>

    <input type="text" v-model="search"/>
    <p>search term {{ search }}</p>
    <div v-for="name in matchingNames" :key="name">
      {{ name }}
    </div>
  </div>
</template>

<script>
import { ref, computed } from 'vue'

export default {
  name: 'HomeView',
  setup(){
    // computed property
    // we used a computed function
    // we fire a function that returns a value, which assigned to "name" var which we are returning in setup
    const name = computed(() => {
      return 'yury'
    })

    const search = ref('')
    const names = ref(['leo', 'misha', 'kolya', 'vasya', 'stepa'])

    const matchingNames = computed(() => {
      return names.value.filter((name) => name.includes(search.value))
    })

    return { name, names, search, matchingNames }
  }
}
</script>

####################################################################################

watch && watchers

<template>
  <div class="home">
    <h1>Home</h1>
    <input type="text" v-model="search"/>
    <p>search term {{ search }}</p>
    <p>Stop Watching</p>
    <button @click="stopWatching">Stop watching</button>
    <div v-for="name in matchingNames" :key="name">
      {{ name }}
    </div>
  </div>
</template>

<script>
import { ref, computed, watch, watchEffect} from 'vue'

export default {
  name: 'HomeView',
  setup(){
    const search = ref('')
    const names = ref(['leo', 'misha', 'kolya', 'vasya', 'stepa'])

    const stopWatch = watch(search, () => {
      console.log('watch function run')
    })

    // watch(search, () => {
    //   console.log('watch function run')
    // })
    // можно и не записывая в переменную watcher сделать

    const stopEffect = watchEffect(() => {
      // this runs initiall when the component first loads or when the setup function first runs
      console.log('watchEffect function ran', search.value)
    })

    // const stopEffect = watchEffect(() => {
    //   // this runs initiall when the component first loads or when the setup function first runs
    //   console.log('watchEffect function ran', search.value)
    // })
    // можно и не записывая в переменную watcher сделать


    const matchingNames = computed(() => {
      return names.value.filter((name) => name.includes(search.value))
    })

    const stopWatching = () => {
      stopWatch()
      stopEffect()
      // чтобы убрать "наблюдение" достаточно просто вызвать функции наблюдатели
    }

    return { names, search, matchingNames, stopWatching }
  }
}
</script>

####################################################################################

props

мы передаем пропсы также как и раньше, но если мы хотим как-то с ними взаимодействовать
то в setup() мы указываем setup(props) а потом образаемся к этим props через
props.name_of_the_prop и так далее

lifecicle hooks

<template>
  <div class="home">
    <h1>Home</h1>
    <PostList v-if="showPosts" :posts="posts"/>
    <button @click="showPosts = !showPosts">toggle posts</button>
    <button @click="posts.pop()">delete a post</button>
  </div>
</template>

<script>
import PostList from '@/components/PostList.vue'
import { ref } from 'vue'

export default {
  name: 'HomeView',
  components: {
    PostList
  },
  setup(){
    const posts = ref([
      { title: 'welcome to the blog', body: 'Lorem ipsum dolor sit, amet consectetur adipisicing elit. Tempore incidunt libero doloremque iusto ad, molestiae reiciendis sapiente. Maiores excepturi, assumenda accusamus fugiat officia placeat maxime reiciendis facilis provident ea consectetur modi ad nemo pariatur sunt doloribus saepe. Molestias voluptate repudiandae aliquam porro architecto labore nobis doloremque distinctio dicta velit tempore officia cumque eligendi, est necessitatibus eos fugiat nemo assumenda! Quos, ea odit! Sequi velit placeat dicta molestiae, voluptas at minus facere voluptatem optio molestias libero in suscipit ratione, esse quas, beatae sint non explicabo officia. Voluptatibus maxime recusandae consectetur nostrum praesentium, eaque ducimus similique repudiandae, ut aspernatur ratione iusto odio!', id: 1},
      { title: 'top 5 css tips', body: 'lorem ipsum', id: 2}
    ])

    const showPosts = ref(true)

    return { posts, showPosts }
  },
  mounted(){
    console.log('mounted using options API')
  }
}
</script>