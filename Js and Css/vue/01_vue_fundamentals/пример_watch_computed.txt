Наблюдаемые watch - функция, которая отрабатывает в тот момент, 
когда какая-либо из моделей (data) была изменена

НАПРИМЕР: мы изменили значение счетчика и та функция, которая за этим счетчиком наблюдает, выполняется

(функция наблюдатель должна иметь такое же название как и модель, которая 
объявлена в компоненте, параметром функция наблюдатель принимает 
новое значение, то есть то на что была изменена новая модель)

    Поверхностный watch 
    watch: {
        selectedSort(newValue){
            console.log(newValue)
        },
        dialogVisible(newValue){
            console.log(newValue)
        }
    }

    Глубокий watch
    watch: {
        post: {
            handler(newVal){
                console.log(newVal)
            },
            deep: true
        }
    }

Вычисляемые computed - это также функция, но это функция которая всегда должна что-то возвращать, как пример она может возвращать отсортированный массив, то есть результат каких-либо вычислей

######################################

для тех кто работал с react - это аналоги useEffect и useMemo

######################################

подробнее о computed

НА УРОВНЕ VUE мы используем computed свойство не как функцию (то есть нам не надо ее вызывать),
мы используем ее как обычную переменную 

рассмотрим на примере

эта функция возвращает отфильтрованный по какому-то условию массив и допустим этот
отфильтрованный массив мы рисуем где-то в шаблоне
Получается что при каждом рендеринге нашего компонента у нас отрабатывает функция ниже

filtredArray(){
	return this.array.filter(....)
}

computed свойства в свою очередь запоминают результат каких-либо вычислений, в случае ниже
они запоминают результат фильтрации - и функция ниже будет вызвана лишь ЕДИНОЖДЫ, в
последующие случаи она будет возвращать лишь запомненный результат, своего рода
кэширование

Заново эта функция будет делать перерасчет только в том случае если измениться зависимость, которая
используется внутри этой функции - в данном случае зависимость это массив array - и если
этот массив будет изменен, например в него добавят новый элемент - эта функция
отработает заново, но, опять же, всего лишь один раз, до тех пор пока массив
не будет изменен еще раз

computed: {
	filtredArray(){
		return this.array.filter(....)
	}
}

ПРИМЕР (мутация исходных данных методом ... аналог watch):

        sortedPosts(){
            // мы не хотим чтобы функция sort мутировала исходный массив с постами
            // поэтому массив с постами разворачиваем в другой массив и сортировать будем уже его
            return [...this.posts].sort((post1, post2) =>
		post1[this.selectedSort]?.localeCompare(post2[this.selectedSort]))
        }

######################################

Computed vs methods

https://vuejs.org/guide/essentials/computed.html#computed-caching-vs-methods

In comparison, a method invocation will always run the function whenever a re-render happens.

computed properties are cached based on their reactive dependencies

Зачем нам нужно кэширование? Представьте что у вас есть большое "вычисляемое свойство" список,
которое подразумевает цикл по грмоадному списку, выполняя множество различных вычислений.

Потом нам может понадобиться другое "вычисляемое свойство", которое зависит от того списка.
Без кэширования, мы будем вызывать "геттеры" списка больше чем нужно.