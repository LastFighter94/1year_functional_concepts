Vue components dispatch 
=> actions commit 
=> mutations mutate 
=> state render 
=> Vue components и заново

во Vue работа с глобальным состоянием осуществляется посредством VUEX

для vue 3 версии vuex используется версии 4

vuex store = некое глобальное хранилище, в котором сосредочены некоторые данные и ряд
функций, которые способны эти данные изменять



для того чтобы создать глобальное хранилище используется функция create store

параметром эта функция принимает объект (у которого есть свои поля)

###################################
state - само состояние, там мы описываем данные, которые будут в нашем приложении
{{ $store.state.likes }}
рекомендуется объявлять в виде функции, которая возвращает объект, тоже самое что
мы бы и делали внутри поле data внутри компонента

    state: () => ({
        
    })

state: function () {
	return {
		...
	}
}


###################################
getters - некоторые computed свойства, аналогично тем которые мы делали в компоненте, своего
рода кэшируемые вычисляемые значения - обязательно должны что-то возвращать
        doubleLikes(state){
            return state.likes * 2 
        }

{{ $store.getters.doubleLikes }}


###################################
mutations - изменять состояние напрямую мы не можем, но можем его изменять с помощью мутаций
эта функции внутри которых мы меняем значения какого-то поля в состоянии

для вызова мутаций используется функция commit @click="$store.commit('name_of_mutation')"
которая параметром принимает название мутации, которую мы хотим вызвать

    mutations: {
        incrementLikes(state){
            state.likes += 1
        },
        decrementLikes(state){
            state.likes -= 1
        }
    },

###################################
actions - функции, которые внутри себя используют мутации, то есть напрямую из actions
изменять состояние не рекомендуется, но мы можем использовать внутри этих экшенов мутации
внутри actions мы делаем какие-то side эффекты, например получаем какие-то данные из сервера,
вызываем мутацию, и сохраняем эти данные в состоянии

параметром они принимают некий объект context, внутри которого следующие поля

{
state, // same as `store.state`, or local state if in module
rootState, // same as `store.state` only in modules
commit, // same as `store.commit` - нужен для вызова мутаций
dispatch, // same as `store.dispatch` - нужен для вызова других actions
getters, // same as `store.getters`, or local getters if in modules
rootGetters // same as `store.getters`, only in modules
}

кроме context, actions может вторым параметром получать payload аргумент, если таковой имеется



также есть modules

один модуль представляет из себя какой-то изолированный кусочек состояния, со своими геттерами,
мутациями и actions и все эти модули по итогу подключаются в один глобальный store



store также подключается к приложению с помощью use в main.js где к app мы подключали router, 
делали mount к #app и так далее (не забываем испортировать сам vuex)



для работы с vuex есть специальный объект $store - с помощью которого можно взаимодействовать
с хранилищем









###################################

nameSpace - момент

как вызывать actions и мутации, когда мы используем модуль

мы по прежнему указываем название мутации, но когда приложение разрастается некоторые
мутации могут носить одинаковые названия и по-хорошему перед названием мутации также
использовать название модуля

и чтобы добиться такого поведения в сам модуль необходимо добавить еще один флаг,
он называется namespaced

namespaced: true

то есть то все что занесено в конкретный модуль будет иметь определенное пространство имен

###################################

во vuex придумали процесс, который упрощает получение
мутаций, стайта, экшэнов и геттеров

import {mapState, mapGetters, mapActions, mapMutations} from 'vuex'

импортируем эти функции в компонент

работа с мутациями и экшэнами ведется в поле methods:

...mapMutations({
	setPage: 'post/setPage'
}),

...mapActions({
	loadMorePosts: 'post/loadMorePosts',
	fetchPosts: 'post/fetchPosts'
})

как замапить состояние и геттеры (теперь оператор spread с соответствующими
функциями мы используем в computed)

        ...mapState({
            posts: state => state.post.posts,
            isPostsLoading: state => state.post.isPostsLoading,
            selectedSort: state => state.post.selectedSort,
            searchQuery: state => state.post.searchQuery,
            page: state => state.post.page,
            limit: state => state.post.limit,
            totalPages: state => state.post.totalPages,
            sortOptions: state => state.post.sortOptions
        }),

        ...mapGetters({
            sortedPosts: 'post/sortedPosts',
            sortedAndSearchedPosts: 'post/sortedAndSearchedPosts'
        })

после этого данные экшэны, мутации, геттеры, состояния доступны в рамках этого компонента,
через this (и без него) можно также к ним обращаться