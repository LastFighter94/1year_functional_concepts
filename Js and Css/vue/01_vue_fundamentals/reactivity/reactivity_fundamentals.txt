Virtual DOM

после парсинга HTML страницы браузер строит DOM дерево,
каждая операция над деревом это крайне ресурсоемкая и тяжелая задача

чтобы оптимизировать процесс ре-рендеринга страницы, VUE под капотом хранит
виртуальное DOM дерево: если говорить совсем кратко
- VUE накапливает количество изменений, которые необходимо отобразить на странице
- после чего сравнивает оригинальную версию DOM и нашу виртуальную копию
- и сразу всей пачкой эти изменения применяются к DOM дереву

О реактивности

Без VUE 

Html
<div id="id">Кол-во лайков = 0</div>
<button id="btn">Поставить лайк</button>

Js
bnt.addEventListener('click', () => {
	counter += 1;
	div.innerText = `Кол-во лайков = ${counter}`
})

данные, с которыми мы работаем, и графическое представление - никак не связаны
приходится руками брать counter и подставлять его в необходимый для нас div

С VUE

Js (во вью подобные значения называются моделями)
data(){
	return {
		likes: 0;
	}
}

Html (шаблон)
<div id="id">Кол-во лайков = 0</div>
<button @click="likes += 1">Поставить лайк</button>

прямо в шаблон встраиваем количество лайков и просто это количество инкремнтируем - в таком случае при нажатии на 
кнопку мы будем сразу видить изменение количества лайков

упор идет больше на работу с данными, нежели с тем как синхронизовать эти данные с нашей страницей

data(){
	return {
		likes: 0;
	}
}

мы объявили модель likes
под капотом VUE обернул эту модель в JS Proxy, после
чего с помощью этого класса добавляет "ловушки" на get, set (геттеры и сеттеры)
то есть на изменения или получения объекта. И в момент попытки изменения модели,
отрабатывает ловушка 
set() {
 render();
}
и VUE вызывает render фунцию и вуаля (если вкратце)

##################################################################

1) https://vuejs.org/guide/essentials/reactivity-fundamentals.html

Options API:

с options API мы используем data() {return {name: 'Yuri'}}, ... чтобы определить состояние компонента

data это функция, которая возвращает объект

Vue вызывает функцию при создании новой сущности компонента и обертывает ее в систему реактивности.

 `this` refers to the component instance.
 `this` относится к сущности компонента.


!!!

It is possible to add a new property directly to this without including it in data. 
However, properties added this way will not be able to trigger reactive updates.

можно добавить свойство к компоненту через this в "хуках" или еще где-либо, но тогда
это свойство не будет обладать реактивностью.

$ _ эти префиксы нужно избегать, так как они могут пересекаться к build-in API components methods

при испольховании methods: {method_name(){this.data_attr == 'something new'}}
надо избегать стрелочных функций, так как "this" контекст будет упущен

Just like all other properties of the component instance, the methods 
are accessible from within the component's template. 
Inside a template they are most commonly used as 
event listeners:

DOM Update Timing

когда ты мутируешь реактивное состояние (data) - DOM обновляется автоматически, однако,
стоит учитывать что DOM обновляется не синхронно - вместо этого VUE буферизирует
обновления до "next tick" в цикле обновления, чтобы убедиться что каждый
компонент обновляется только один раз вне зависимости от того, сколько
изменений в состояние вы внесли.

NEXT_TICK

!!!

To wait for the DOM update to complete after a state change, you can use the nextTick() global API:

import { nextTick } from 'vue'

export default {
  methods: {
    increment() {
      this.count++
      nextTick(() => {
        // access updated DOM
      })
    }
  }
}