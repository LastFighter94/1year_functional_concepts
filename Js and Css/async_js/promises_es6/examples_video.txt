example_2

в примечаниях классический fetch - обертка на xhr request 

когда используем async await мы просто логику промиса закидываем в 
функцию, добавляем ей async свойство, а resolve промиса делаем 
с помощью await - и результат пишем в переменную можно 
оберуть все это дело в try catch finally по желанию



example_3

в примечаниях вызываем getUserMedia с параметром {video: true} и получаем результат, который
пишем в mediaStream, который по итогу записываем в video.srcObject

когда используем async await - в данном случае Function Expression async await, то
мы просто resolve промиса записываем в переменную через await: классика



example_4

в функции resolve промиса мы пишем логику при успешном выполнении, в reject пишем
сценарии разрыва цепочки промиса, что без catch сломает код (по-видимому),
остальное как в примере выше

можно просто вызвать resolve() и это будет означать что промис завершил свое выполнение
также в resolve мы можем передать параметр для следующей then цепочки


example_5

здесь пример кастомной задержки через промис

https://www.youtube.com/watch?v=SLQAVVziUzg

#########################################################

example_6

пока не выполнятся все промисы, в консоль all promises не выведется
этот метод ждет пока выполнятся все промисы

race promises принимает набор промисов - и когда выполнится первый промис, самый быстрый
- тогда он и отработает (для того чтобы определить какой промис был первый выполнен)

https://www.youtube.com/watch?v=1idOY3C1gYU